#include "Tlc5940.h"                                                                // подключить библиотеку обслуживани€ LED-драйвера

#define Sonar1trig  8                                                               // вход "Trig" "нижнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)
#define Sonar1echo  2                                                               // выход "Echo" "нижнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)
#define Sonar1reset 4                                                               // управление перезагрузкой "нижнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)

#define Sonar2trig  6                                                               // вход "Trig" "верхнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)
#define Sonar2echo  7                                                               // выход "Echo" "верхнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)
#define Sonar2reset 5                                                               // управление перезагрузкой "верхнего" сонара (имеет смысл только при использовании —ќЌј–ќ¬)

#define PIR1out 8                                                                   // выход "нижнего" PIR (имеет смысл только при использовании PIR-сенсоров)
#define PIR2out 6                                                                   // выход "верхнего" PIR (имеет смысл только при использовании PIR-сенсоров)

#define Sonar1limit 30                                                              // см, если обнаружена дистанци€ меньше, чем это число, то сонар считаетс€ сработавшим
#define Sonar2limit 30                                                              // см, если обнаружена дистанци€ меньше, чем это число, то сонар считаетс€ сработавшим

// === ѕќЋ№«ќ¬ј“≈Ћ№— »≈ Ќј—“–ќ… » =============================================================================

#define SensorPIR false                                                             // выберите тип сенсора: FALSE = сонары SRF05,  TRUE = PIR сенсоры
#define UseResetSonar true                                                          // выберите, использовать ли механизм reset (имеет смысл только при использовании —ќЌј–ќ¬)
#define N 8                                                                        	// 2...16 - установите количество подсвечиваемых ступеней
#define Speed 2.0                                                                   // >=1.2 - задайте скорость включени€/выключени€ освещени€ ступеней
#define PWM_InitialValue 500                                                       	// 0...4095 - задайте уровень €ркости первой и последней ступеней в режиме ожидани€
#define LightOFF_Delay 7000                                                         // мс, задайте врем€ задержки отключени€ освещени€ после включени€ последней ступени

// ============================================================================================================

int StairsPWMValue[16];                                                             // массив значений уровней €ркости (0...4096) ступеней. ¬се операции только с ним, далее через PWM_Output передаютс€ в LED-драйвер 

byte Sensor1_IgnoreCount = 0;                                                       // счетчик игнорировани€ срабатывани€ сенсора 1 (счетчик спускающихс€ по лестнице)
byte Sensor2_IgnoreCount = 0;                                                       // счетчик игнорировани€ срабатывани€ сенсора 2 (счетчик поднимающихс€ по лестнице)

boolean Sensor1 = false;                                                            // сенсор 1 зафиксировал движение 
boolean Memory1 = false;                                                            // пам€ть сенсора 1
boolean Sensor1_ON = false;                                                         // управл€ющий сигнал сенсора 1

boolean Sensor2 = false;                                                            // сенсор 2 зафиксировал движение
boolean Memory2 = false;                                                            // пам€ть сенсора 2
boolean Sensor2_ON = false;                                                         // управл€ющий сигнал сенсора 2

boolean AllLightOn = false;                                                         // освещение включено полностью, требуетс€ ожидание в таком состо€нии
boolean ON_BottomTop = false;                                                       // требуетс€ включение ступеней снизу вверх
boolean OFF_BottomTop = false;                                                      // требуетс€ выключение ступеней снизу вверх
boolean ON_TopBottom = false;                                                       // требуетс€ включение ступеней сверху вниз
boolean OFF_TopBottom = false;                                                      // требуетс€ выключение ступеней сверху вниз
boolean InitialState = true;                                                        // "дежурный" режим лестницы, т.н. исходное состо€ние
boolean direct = false;                                                             // направление : false = снизу вверх, true = сверху вниз

unsigned long PreTime;                                                              // отметка системного времени в предыдущем цикле
unsigned long ActTime;                                                              // отметка системного времени в текущем цикле

long Cycle;                                                                         // мс, длительность цикла
long AllLight_OffDelay;                                                             // мс, оставшеес€ врем€ до выключени€ освещени€ лестницы


// ===== ѕќƒ√ќ“ќ¬ ј ===========================================================================================

void setup() {  

//  Serial.begin(9600);
  Tlc.init();                                                                       // инициализаци€ LED-драйвера
  delay(500);                                                                       // задержка дл€ выполнени€ инициализации LED-драйвера 
  for (byte i = 1; i < 16; i++) StairsPWMValue[i] = 0;                              // обнулить массив значений €ркости ступеней начина€ со 2-й ступени
  StairsPWMValue[0] = PWM_InitialValue;                                             // выставление дефолтной €ркости 1-ой ступени
  StairsPWMValue[N - 1] = PWM_InitialValue;                                         // выставление дефолтной €ркости последней используемой ступени
  PWM_Output();                                                                     // передать в LED-драйвер начальные уровни €ркости

 // - инициализаци€ сенсора 1  

  if (SensorPIR) pinMode (PIR1out, INPUT);                                          // PIR сенсор
  else {                                                                            // сонар SRF05
    pinMode (Sonar1trig, OUTPUT);
    pinMode (Sonar1echo, INPUT);
    pinMode (Sonar1reset, OUTPUT);
    digitalWrite (Sonar1trig, LOW);
  }
  Sensor1 = false;
  Memory1 = false;
  
// - инициализаци€ сенсора 2 

  if (SensorPIR) pinMode (PIR2out, INPUT);                                          // PIR сенсор
  else {                                                                            // сонар SRF05
    pinMode (Sonar2trig, OUTPUT);
    pinMode (Sonar2echo, INPUT);
    pinMode (Sonar2reset, OUTPUT);
    digitalWrite (Sonar2trig, LOW);
  }
  Sensor2 = false;
  Memory2 = false;

// - инициализаци€ состо€ни€ 

  ON_BottomTop = false;                                                        
  ON_TopBottom = false;
  
  PreTime = millis();                                                               // сохранить системное врем€
}  

// ===== ќ—Ќќ¬Ќќ… ÷» Ћ ========================================================================================

void loop() { 

  InitialState = !((ON_TopBottom) || (OFF_TopBottom) || (ON_BottomTop) || (OFF_BottomTop) || (AllLightOn));
  if (InitialState) {                                                               // если лестница находитс€ в исходном (выключенном) состо€нии, сбросить флаги-"потер€шки" на вс€кий случай
    Sensor1_IgnoreCount = 0;                                                        // счетчик игнорировани€ сенсора 1
    Sensor2_IgnoreCount = 0;                                                        // счетчик игнорировани€ сенсора 2
  }

// - проверить состо€ние "Ќ»∆Ќ≈√ќ" сенсора 

  if (!SensorPIR) {                													                        // сканирование пространства перед сонаром 1
    digitalWrite(Sonar1trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(Sonar1trig, LOW);
    byte distance = pulseIn(Sonar1echo, HIGH, 5000) / 58 ;                  				// расчет дистанции до преп€тстви€ (5000 - таймаут, то есть не ждать сигнала более 5мс) 
	Sensor1 = (distance > 0) && (distance <= Sonar1limit);							              // SRF05 : сонар 1 зафиксировал присутствие
	if (UseResetSonar && !(distance > 0)) digitalWrite(Sonar1reset, LOW);			        // перезапуск зависшего сонара - отключить питание до конца цикла
	}
  else Sensor1 = (digitalRead(PIR1out) == LOW);										                  // PIR : сенсор 1 зафиксировал присутствие

  Sensor1_ON = Sensor1 && !(Sensor1_IgnoreCount > 0);                           	  // счетчик игнорировани€ сенсора 1 не более 0 - сформировать управл€ющий сигнал 
  if (Sensor1 && !Memory1) {														                            // фронт срабатывани€ сенсора 1
    if (Sensor1_IgnoreCount > 0) Sensor1_IgnoreCount-- ;                            // если требуетс€ игнорировть сонар 1, декремент счетчика игнорировани€ сенсора 1 (веро€тно, кто-то закончил спуск по лестнице)
    else Sensor2_IgnoreCount++ ;                                                    // иначе, инкремент счетчика игнорировани€ сенсора 2 (веро€тно, кто-то начал подниматьс€ по лестнице)    
  }
  Memory1 = Sensor1 ;																                                // запомнить состо€ние сенсора
 
// - проверить состо€ние "¬≈–’Ќ≈√ќ" сенсора 

  if (!SensorPIR) {                													                        // сканирование пространства перед сонаром 2
    digitalWrite(Sonar2trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(Sonar2trig, LOW);
    byte distance = pulseIn(Sonar2echo, HIGH, 5000) / 58 ;                  				// расчет дистанции до преп€тстви€ (5000 - таймаут, то есть не ждать сигнала более 5мс) 
	Sensor2 = (distance > 0) && (distance <= Sonar2limit);						                // SRF05 : сонар 2 зафиксировал присутствие
	if (UseResetSonar && !(distance > 0)) digitalWrite(Sonar2reset, LOW);			        // перезапуск зависшего сонара - отключить питание до конца цикла
	}
  else Sensor2 = (digitalRead(PIR2out) == LOW);										                  // PIR : сенсор 2 зафиксировал присутствие

  Sensor2_ON = Sensor2 && !(Sensor2_IgnoreCount > 0);                           	  // счетчик игнорировани€ сенсора 2 не более 0 - сформировать управл€ющий сигнал 
  if (Sensor2 && !Memory2) {														                            // фронт срабатывани€ сенсора 2
    if (Sensor2_IgnoreCount > 0) Sensor2_IgnoreCount-- ;                            // если требуетс€ игнорировть сонар 2, декремент счетчика игнорировани€ сенсора 2 (веро€тно, кто-то закончил подъем по лестнице)
    else Sensor1_IgnoreCount++ ;                                                    // иначе, инкремент счетчика игнорировани€ сенсора 1 (веро€тно, кто-то начал спускатьс€ по лестнице)    
  }
  Memory2 = Sensor2 ;																                                // запомнить состо€ние сенсора
  
// - освещение лестницы включено

  if (AllLightOn) {                                                                	// если лестница находитс€ во включенном состо€нии, можно сбросить флаги-"потер€шки" на вс€кий случай
    ON_BottomTop = false;                                                        	  // включение освещени€ снизу вверх
    ON_TopBottom = false;                                                        	  // включение освещени€ сверху вниз
  }
  
   
// - действи€ при срабатывани€ "Ќ»∆Ќ≈√ќ" сенсора 
  
  if (Sensor1_ON && InitialState) ON_BottomTop = true;                              // при срабатывании сенсора из исходного состо€ни€ лестницы начать включение освещени€ ступеней снизу вверх
  else if (Sensor1_ON && AllLightOn) AllLight_OffDelay = LightOFF_Delay ;           // если освещение уже полностью включено, обновить отсчет задержки выключени€ освещени€   	
  else if (Sensor1_ON && OFF_BottomTop) {                                           // если происходит выключение освещени€ ступеней снизу вверх,
    OFF_BottomTop = false;                                                          // прекратить выключение освещени€
    ON_BottomTop = true;                                                            // вновь начать включение освещени€ ступеней снизу вверх
  }
/*
  else if (Sensor1_ON && ON_TopBottom) {                                            // если происходит включение освещени€ ступеней сверху вниз
    ON_TopBottom = false;                                                           // прекратить включение освещени€ сверху вниз
    ON_BottomTop = true;                                                            // начать включение освещени€ ступеней снизу вверх
  }
*/  
  else if (Sensor1_ON && OFF_TopBottom) {                                           // если происходит выключение освещени€ ступеней сверху вниз
    OFF_TopBottom = false;                                                          // прекратить выключение освещени€ сверху вниз
    ON_BottomTop = true;                                                            // начать включение освещени€ ступеней снизу вверх
  }

// - действи€ при срабатывани€ "¬≈–’Ќ≈√ќ" сенсора 

  if (Sensor2_ON && InitialState) ON_TopBottom = true;                              // при срабатывании сенсора из исходного состо€ни€ лестницы начать включение освещени€ ступеней сверху вниз
  else if (Sensor2_ON && AllLightOn) AllLight_OffDelay = LightOFF_Delay ;           // если освещение уже полностью включено, обновить отсчет задержки выключени€ освещени€   	
  else if (Sensor2_ON && OFF_TopBottom) {                                       	  // если происходит выключение освещени€ ступеней сверху вниз
    OFF_TopBottom = false;                                                          // прекратить выключение освещени€
    ON_TopBottom = true;                                                            // вновь начать включение освещени€ ступеней сверху вниз
  }
/*  
  else if (Sensor2_ON && ON_BottomTop) {                                        	  // если происходит включение освещени€ ступеней снизу вверх
    ON_BottomTop = false;                                                           // прекратить включение освещени€ снизу вверх
    ON_TopBottom = true;                                                            // начать включение освещени€ ступеней сверху вниз
  }
*/  
  else if (Sensor2_ON && OFF_BottomTop) {                                       	  // если происходит выключение освещени€ ступеней снизу вверх
    OFF_BottomTop = false;                                                          // прекратить выключение освещени€ снизу вверх
    ON_TopBottom = true;                                                            // начать включение освещени€ ступеней сверху вниз
  }

// - определение необходимости и направлени€ выключени€ освещени€

	if (AllLightOn && !(AllLight_OffDelay > 0)) {                                  	  // пора гасить освещение
    OFF_BottomTop = !direct;                                                        // снизу вверх
    OFF_TopBottom = direct;                                                         // сверху вниз
  }
 
// - управление включением/выключением освещени€ ступеней

  if (ON_BottomTop) BottomTopLightON();                                             // вызов процедуры включени€ ступеней снизу вверх
  if (OFF_BottomTop) BottomTopLightOFF();                                           // вызов процедуры выключени€ ступеней снизу вверх
  if (ON_TopBottom) TopBottomLightON();                                             // вызов процедуры включени€ ступеней сверху вниз
  if (OFF_TopBottom) TopBottomLightOFF();                                           // выключение ступеней сверху вниз
  PWM_Output();                                                                     // передать в LED-драйвер актуальные уровни €ркости

// - завершение цикла

  delay(50);                                                                        // задержка дл€ обеспечени€ паузы перед следующим опросом сонаров
  if (!SensorPIR) {                                                                 // восстановление питани€, если был перезапуск сонаров
    digitalWrite (Sonar1reset, HIGH);                                               // всегда должен быть HIGH, дл€ перезапуска сонара 1 установить в LOW
    digitalWrite (Sonar1reset, HIGH);                                               // всегда должен быть HIGH, дл€ перезапуска сонара 2 установить в LOW
  } 
  
  ActTime = millis();                                                               // отметка времени дл€ расчета длительности цикла
  Cycle = ActTime - PreTime;                                                        // прошло времени с предыдущего цикла программы 

  if (AllLight_OffDelay > 0) AllLight_OffDelay = AllLight_OffDelay - Cycle;         // если врем€ освещени€ лестницы не истекло, уменьшить на длительность цикла
  else AllLight_OffDelay = 0;                                                       // иначе, врем€ до начала отключени€ освещени€ = 0
 
  PreTime = millis();                                                               // отметка времени дл€ расчета длительности цикла

}


// ===== ѕ–ќ÷≈ƒ”–ј ¬ Ћё„≈Ќ»я —Ќ»«” ¬¬≈–’ - ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќќ≈ ”¬≈Ћ»„≈Ќ»≈ ”–ќ¬Ќ≈… я– ќ—“» —“”ѕ≈Ќ≈… ===============

void BottomTopLightON() { 
  direct = false;                                                                   // запомнить направление = снизу вверх
  for (byte i = 0; i < N; i++) {                                                    // перебор ступеней снизу вверх
    if (StairsPWMValue[i] < 1) {													                          // если очередна€ ступень выключена,
	  StairsPWMValue[i] = 5; 	  									                                    // задать дл€ неЄ начальный уровень €ркости
	  return;																		                                      // и выйти из процедуры
	  }  
	  else if (StairsPWMValue[i] < 4095 ){                                     		    // иначе, если уровень €ркости ступени меньше максимального,
      StairsPWMValue[i] = StairsPWMValue[i] * Speed ; 	  								          // увеличить уровень €ркости  
	  if (StairsPWMValue[i] > 4095 ) StairsPWMValue[i] = 4095 ;               		    // ограничить максимальную €ркость
      return;                                                                       // и выйти из процедуры                            
    }
  }  
	AllLightOn = true;                                                            	   // освещение лестницы полностью включено
  AllLight_OffDelay = LightOFF_Delay;
  ON_BottomTop = false;                                                         	   // закончить включение ступеней снизу вверх
}

// ===== ѕ–ќ÷≈ƒ”–ј ¬џ Ћё„≈Ќ»я —Ќ»«” ¬¬≈–’ - ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќќ≈ —Ќ»∆≈Ќ»≈ ”–ќ¬Ќ≈… я– ќ—“» —“”ѕ≈Ќ≈… ===============

void BottomTopLightOFF() {  
  AllLightOn = false;                                                               // сбросить признак того, что освещение лестницы полностью включено
  for (byte i = 0; i < N ; i++) {                                                   // перебор ступеней снизу вверх
    if (((i == 0) || (i == N-1)) && (StairsPWMValue[i] > PWM_InitialValue)) {       // если это перва€ или последн€€ ступень и уровень €ркости выше дежурного уровн€,
      StairsPWMValue[i] = StairsPWMValue[i] / Speed ;                          // уменьшить €ркость
	  if (StairsPWMValue[i] < PWM_InitialValue ) StairsPWMValue[i] = PWM_InitialValue ; // ограничить минимальную €ркость
      return;                                                                       // и выйти из процедуры	  
    }  
    else if ((i != 0) && (i != N-1) && (StairsPWMValue[i] > 0)) {                   // дл€ остальных ступеней, если уровень €ркости выше "0",
      StairsPWMValue[i] = StairsPWMValue[i] / Speed ;                               // уменьшить €ркость
	  if (StairsPWMValue[i] < 5 ) StairsPWMValue[i] = 0 ; 							              // ограничить минимальную €ркость
      return;                                                                       // и выйти из процедуры
    }
  }
  OFF_BottomTop = false;                                                            // закончить выключение ступеней снизу вверх
}

// ===== ѕ–ќ÷≈ƒ”–ј ¬ Ћё„≈Ќ»я —¬≈–’” ¬Ќ»« - ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќќ≈ ”¬≈Ћ»„≈Ќ»≈ ”–ќ¬Ќ≈… я– ќ—“» —“”ѕ≈Ќ≈… ===============

void TopBottomLightON() { 
  direct = true;                                                                    // запомнить направление = сверху вниз
  for (byte i = N; i > 0; i--) {                                                    // перебор ступеней сверху вниз
    if (StairsPWMValue[i-1] < 1) {                                                 	// если очередна€ ступень выключена,
 	  StairsPWMValue[i-1] = 5; 	  									                                  // задать дл€ неЄ начальный уровень €ркости
	  return;																		                                      // и выйти из процедуры
	  }  
	  else if (StairsPWMValue[i-1] < 4095 ){                                     		  // иначе, если уровень €ркости ступени меньше максимального,
      StairsPWMValue[i-1] = StairsPWMValue[i-1] * Speed ; 	  								      // увеличить уровень €ркости  
	    if (StairsPWMValue[i-1] > 4095 ) StairsPWMValue[i-1] = 4095 ;               	// ограничить максимальную €ркость
      return;                                                                       // и выйти из процедуры                            
    } 
  } 
  AllLightOn = true;                                                            	  // освещение лестницы полностью включено
  AllLight_OffDelay = LightOFF_Delay;
  ON_TopBottom = false;                                                         	  // закончить включение ступеней сверху вниз
}

// ===== ѕ–ќ÷≈ƒ”–ј ¬џ Ћё„≈Ќ»я —¬≈–’” ¬Ќ»« - ѕќ—Ћ≈ƒќ¬ј“≈Ћ№Ќќ≈ —Ќ»∆≈Ќ»≈ ”–ќ¬Ќ≈… я– ќ—“» —“”ѕ≈Ќ≈… ================

void TopBottomLightOFF() {  
  AllLightOn = false;                                                               // сбросить признак того, что освещение лестницы полностью включено
  for (byte i = N ; i >0; i--) {                                                    // перебор ступеней вниз, начина€ с верхней
    if (((i == 1) || (i == N)) && (StairsPWMValue[i-1] > PWM_InitialValue)) {       // если это перва€ или последн€€ ступень и уровень €ркости выше дежурного уровн€,
      StairsPWMValue[i-1] = StairsPWMValue[i-1] / Speed ;                           // уменьшить €ркость
	  if (StairsPWMValue[i-1] < PWM_InitialValue ) StairsPWMValue[i-1] = PWM_InitialValue ; // ограничить минимальную €ркость
      return;                                                                       // и выйти из процедуры	  
    }  
    else if ((i != 1) && (i != N) && (StairsPWMValue[i-1] > 0)) {                   // дл€ остальных ступеней, если уровень €ркости выше "0",
      StairsPWMValue[i-1] = StairsPWMValue[i-1] / Speed ;                           // уменьшить €ркость
	  if (StairsPWMValue[i-1] < 5 ) StairsPWMValue[i-1] = 0 ; 							          // ограничить минимальную €ркость
      return;                                                                       // и выйти из процедуры
    }
  }
  OFF_TopBottom = false;                                                            // закончить выключение ступеней сверху вниз
}


// ===== ѕ–ќ÷≈ƒ”–ј ѕ≈–≈ƒј„» ”ѕ–ј¬Ћяёў»’ —»√ЌјЋќ¬ ¬ LED-ƒ–ј…¬≈– TLC 5940 =======================================

void PWM_Output() {  
  for (int i = 0; i < 15; i++) Tlc.set(i, StairsPWMValue[i]);                      	// €ркость ступеней в диапазоне 0...4096 
  Tlc.update();
}